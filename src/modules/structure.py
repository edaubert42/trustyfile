"""
Module E: PDF Structure Analysis

This module analyzes the internal structure of a PDF to detect manipulation.

What we check:
1. Incremental updates - Each edit adds a revision to the PDF
2. Deleted objects - Content removed but still in file (ghost data)
3. JavaScript - Very suspicious in invoices/certificates
4. Annotations - Hidden comments or notes
5. Multiple versions - Sign of editing

Why structure matters for fraud detection:
- A PDF generated by a billing system has ONE version
- A PDF edited manually has MULTIPLE versions (incremental updates)
- Deleted content can be recovered from the file
- JavaScript in an invoice is almost always malicious

Technical background:
PDF files are "append-only" by default. When you edit a PDF:
1. Original content stays in the file
2. New content is appended at the end
3. A new "xref" table points to the updated objects
4. The file grows with each edit

This means we can detect:
- How many times the PDF was modified
- What objects were deleted (but still present)
- If content was added after initial creation
"""

import re
import logging
from dataclasses import dataclass
import fitz  # PyMuPDF

from src.models import Flag, ModuleResult
from src.extractors.pdf_extractor import PDFData

logger = logging.getLogger(__name__)


# =============================================================================
# STRUCTURE ANALYSIS FUNCTIONS
# =============================================================================

def count_incremental_updates(pdf_path: str) -> int:
    """
    Count the number of incremental updates (revisions) in a PDF.

    Each time a PDF is edited and saved, a new "%%EOF" marker is added.
    A clean PDF has exactly 1 EOF. Multiple EOFs = multiple edits.

    Args:
        pdf_path: Path to the PDF file

    Returns:
        Number of EOF markers found (1 = clean, >1 = edited)
    """
    try:
        with open(pdf_path, 'rb') as f:
            content = f.read()

        # Count %%EOF markers
        # Each incremental update ends with %%EOF
        eof_count = content.count(b'%%EOF')

        return eof_count
    except Exception as e:
        logger.error(f"Error counting incremental updates: {e}")
        return 1  # Assume clean if we can't read


def check_incremental_updates(pdf_path: str) -> list[Flag]:
    """
    Check if the PDF has been edited (has incremental updates).

    Args:
        pdf_path: Path to the PDF file

    Returns:
        List of flags if multiple versions detected
    """
    flags = []

    eof_count = count_incremental_updates(pdf_path)

    if eof_count > 1:
        # Multiple EOFs = multiple edits
        edits = eof_count - 1

        if edits >= 3:
            severity = "critical"
            message = f"PDF has been edited {edits} times (very suspicious)"
        elif edits == 2:
            severity = "high"
            message = f"PDF has been edited {edits} times"
        else:
            severity = "high"
            message = f"PDF has been edited {edits} time"

        flags.append(Flag(
            severity=severity,
            code="STRUCT_INCREMENTAL_UPDATES",
            message=message,
            details={
                "eof_count": eof_count,
                "edit_count": edits,
                "explanation": "Each edit adds a new version to the PDF. "
                              "Legitimate invoices are generated once and never modified."
            }
        ))

    return flags


def check_javascript(pdf_path: str) -> list[Flag]:
    """
    Check if the PDF contains JavaScript.

    JavaScript in a PDF is very suspicious for invoices/certificates.
    It could be used for:
    - Malware delivery
    - Dynamic content modification
    - Phishing attacks

    Args:
        pdf_path: Path to the PDF file

    Returns:
        List of flags if JavaScript detected
    """
    flags = []

    try:
        doc = fitz.open(pdf_path)

        # Check for JavaScript in the document
        # PyMuPDF can extract JS from various locations

        # Method 1: Check document-level JavaScript
        js_found = False
        js_locations = []

        # Check PDF catalog for JavaScript
        try:
            # Get the PDF trailer/catalog
            xref_len = doc.xref_length()

            for xref in range(1, xref_len):
                try:
                    obj_str = doc.xref_object(xref)
                    if obj_str:
                        # Look for JavaScript indicators
                        if '/JavaScript' in obj_str or '/JS' in obj_str:
                            js_found = True
                            js_locations.append(f"xref {xref}")
                except Exception:
                    continue
        except Exception as e:
            logger.debug(f"Error checking xref for JS: {e}")

        # Method 2: Check for JavaScript in annotations
        for page_num in range(len(doc)):
            page = doc[page_num]

            # Check annotations
            for annot in page.annots() or []:
                annot_info = annot.info
                if annot_info:
                    # Check for JavaScript actions
                    if 'javascript' in str(annot_info).lower():
                        js_found = True
                        js_locations.append(f"annotation on page {page_num + 1}")

        doc.close()

        if js_found:
            flags.append(Flag(
                severity="critical",
                code="STRUCT_JAVASCRIPT_DETECTED",
                message="PDF contains JavaScript code (very suspicious for documents)",
                details={
                    "locations": js_locations,
                    "warning": "JavaScript in PDFs can be used for malware or phishing. "
                              "Legitimate invoices never contain JavaScript."
                }
            ))

    except Exception as e:
        logger.error(f"Error checking for JavaScript: {e}")

    return flags


def check_hidden_annotations(pdf_path: str) -> list[Flag]:
    """
    Check for hidden or suspicious annotations in the PDF.

    Annotations can contain:
    - Hidden comments (review history)
    - Invisible links
    - Form fields
    - Redactions (covered content)

    Args:
        pdf_path: Path to the PDF file

    Returns:
        List of flags if suspicious annotations found
    """
    flags = []

    try:
        doc = fitz.open(pdf_path)

        hidden_annots = []
        suspicious_annots = []

        for page_num in range(len(doc)):
            page = doc[page_num]

            for annot in page.annots() or []:
                annot_type = annot.type[1]  # Get annotation type name

                # Check for hidden annotations (opacity = 0 or invisible flag)
                if annot.opacity == 0:
                    hidden_annots.append({
                        "page": page_num + 1,
                        "type": annot_type,
                        "reason": "opacity is 0 (invisible)"
                    })

                # Check for suspicious annotation types
                suspicious_types = ['FileAttachment', 'Sound', 'Movie', 'Screen', 'RichMedia']
                if annot_type in suspicious_types:
                    suspicious_annots.append({
                        "page": page_num + 1,
                        "type": annot_type,
                        "reason": f"suspicious type: {annot_type}"
                    })

        doc.close()

        if hidden_annots:
            flags.append(Flag(
                severity="high",
                code="STRUCT_HIDDEN_ANNOTATIONS",
                message=f"PDF contains {len(hidden_annots)} hidden annotation(s)",
                details={
                    "annotations": hidden_annots,
                    "explanation": "Hidden annotations may contain concealed information."
                }
            ))

        if suspicious_annots:
            flags.append(Flag(
                severity="high",
                code="STRUCT_SUSPICIOUS_ANNOTATIONS",
                message=f"PDF contains suspicious annotation types",
                details={
                    "annotations": suspicious_annots,
                    "explanation": "These annotation types are unusual for invoices."
                }
            ))

    except Exception as e:
        logger.error(f"Error checking annotations: {e}")

    return flags


def check_embedded_files(pdf_path: str) -> list[Flag]:
    """
    Check for embedded files in the PDF.

    Embedded files can be used to hide:
    - Malware
    - Additional documents
    - Executable code

    Args:
        pdf_path: Path to the PDF file

    Returns:
        List of flags if embedded files found
    """
    flags = []

    try:
        doc = fitz.open(pdf_path)

        # Get embedded files
        embedded_count = doc.embfile_count()

        if embedded_count > 0:
            embedded_files = []

            for i in range(embedded_count):
                info = doc.embfile_info(i)
                embedded_files.append({
                    "name": info.get("name", "unknown"),
                    "size": info.get("size", 0),
                })

            # Determine severity based on file types
            dangerous_extensions = ['.exe', '.js', '.vbs', '.bat', '.cmd', '.ps1', '.dll']
            has_dangerous = any(
                any(f["name"].lower().endswith(ext) for ext in dangerous_extensions)
                for f in embedded_files
            )

            if has_dangerous:
                severity = "critical"
                message = "PDF contains embedded executable files (malware risk!)"
            else:
                severity = "high"
                message = f"PDF contains {embedded_count} embedded file(s)"

            flags.append(Flag(
                severity=severity,
                code="STRUCT_EMBEDDED_FILES",
                message=message,
                details={
                    "file_count": embedded_count,
                    "files": embedded_files,
                    "warning": "Embedded files in invoices are suspicious."
                }
            ))

        doc.close()

    except Exception as e:
        logger.error(f"Error checking embedded files: {e}")

    return flags


def check_acroform(pdf_path: str) -> list[Flag]:
    """
    Check for AcroForm (interactive forms) in the PDF.

    While forms are legitimate in some contexts, they're suspicious
    in invoices because they can be used to:
    - Collect data (phishing)
    - Execute JavaScript
    - Modify displayed content

    Args:
        pdf_path: Path to the PDF file

    Returns:
        List of flags if forms detected
    """
    flags = []

    try:
        doc = fitz.open(pdf_path)

        # Check for form fields
        has_forms = False
        form_fields = []

        for page_num in range(len(doc)):
            page = doc[page_num]

            # Get widgets (form fields)
            widgets = page.widgets()
            if widgets:
                for widget in widgets:
                    has_forms = True
                    form_fields.append({
                        "page": page_num + 1,
                        "type": widget.field_type_string,
                        "name": widget.field_name or "unnamed",
                    })

        doc.close()

        if has_forms:
            flags.append(Flag(
                severity="medium",
                code="STRUCT_ACROFORM_DETECTED",
                message=f"PDF contains {len(form_fields)} form field(s)",
                details={
                    "fields": form_fields[:10],  # Limit to first 10
                    "total_count": len(form_fields),
                    "note": "Interactive forms are unusual in invoices."
                }
            ))

    except Exception as e:
        logger.error(f"Error checking AcroForm: {e}")

    return flags


def check_object_streams(pdf_path: str) -> list[Flag]:
    """
    Check for suspicious patterns in PDF object streams.

    Look for:
    - Deleted objects that are still in the file
    - Unusual object counts
    - Signs of manipulation

    Args:
        pdf_path: Path to the PDF file

    Returns:
        List of flags if suspicious patterns found
    """
    flags = []

    try:
        with open(pdf_path, 'rb') as f:
            content = f.read()

        # Count "obj" declarations vs "endobj"
        obj_count = len(re.findall(rb'\d+\s+\d+\s+obj', content))
        endobj_count = content.count(b'endobj')

        # Look for free objects (deleted but still present)
        # In xref table, 'f' means free (deleted)
        free_objects = len(re.findall(rb'\d{10}\s+\d{5}\s+f', content))

        if free_objects > 5:
            flags.append(Flag(
                severity="medium",
                code="STRUCT_DELETED_OBJECTS",
                message=f"PDF contains {free_objects} deleted objects (ghost data)",
                details={
                    "free_objects": free_objects,
                    "explanation": "Deleted objects may contain previous versions of content. "
                                  "This suggests the document was edited."
                }
            ))

    except Exception as e:
        logger.error(f"Error checking object streams: {e}")

    return flags


# =============================================================================
# SEVERITY POINTS
# =============================================================================

SEVERITY_POINTS = {
    "low": 5,
    "medium": 15,
    "high": 30,
    "critical": 50,
}


# =============================================================================
# MAIN ANALYSIS FUNCTION
# =============================================================================

def analyze_structure(pdf_data: PDFData) -> ModuleResult:
    """
    Analyze PDF internal structure for signs of manipulation.

    Args:
        pdf_data: Extracted PDF data

    Returns:
        ModuleResult with score, flags, and confidence
    """
    all_flags = []

    # Run all structure checks
    all_flags.extend(check_incremental_updates(pdf_data.file_path))
    all_flags.extend(check_javascript(pdf_data.file_path))
    all_flags.extend(check_hidden_annotations(pdf_data.file_path))
    all_flags.extend(check_embedded_files(pdf_data.file_path))
    all_flags.extend(check_acroform(pdf_data.file_path))
    all_flags.extend(check_object_streams(pdf_data.file_path))

    # Calculate score
    score = 100
    for flag in all_flags:
        score -= SEVERITY_POINTS[flag.severity]
    score = max(0, score)

    # High confidence - we can reliably analyze PDF structure
    confidence = 0.95

    return ModuleResult(
        module="structure",
        flags=all_flags,
        score=score,
        confidence=confidence,
    )
